= Rust 2019
–ê–ª–µ–∫—Å–µ–π –ö–ª–∞–¥–æ–≤ <aleksey.kladov@gmail.com>
:icons: font
:lecture: –õ–µ–∫—Ü–∏—è 2: –í—Ä–µ–º—è –ñ–∏–∑–Ω–∏, ADT
:table-caption!:
:example-caption!:

== –°—Å—ã–ª–∫–∏

* https://www.rust-lang.org/
* https://rustup.rs/
* https://doc.rust-lang.org/book/
* https://doc.rust-lang.org/rust-by-example/
* https://doc.rust-lang.org/std/

–£ Rust **–ø—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**, –º–æ–∂–Ω–æ –≤—ã—É—á–∏—Ç—å —è–∑—ã–∫ –ø–æ –∫–Ω–∏–∂–∫–µ.

== Move

- –æ–±—ä–µ–∫—Ç—ã —É–Ω–∏—á—Ç–æ–∂–∞—é—Ç—Å—è –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏
- –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ, –ø–µ—Ä–µ–¥–∞—á–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –≤–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—é—Ç –≤–ª–∞–¥–µ–Ω–∏–µ
- move —ç—Ç–æ `memcpy`
- –æ–±—ä–µ–∫—Ç—ã –æ–±—Ä–∞–∑—É—é—Ç –¥–µ—Ä–µ–≤–æ:
+
[source,rust]
----
struct Function {
    parameteres: Vec<Parameter>,
    return_type: Box<Type>,
}

fn main() {
    let fns: Vec<Function> = ...;
    drop(fns); // —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –ø–∞–º—è—Ç—å
}
----

== Copy

–û–±—ä–µ–∫—Ç—ã, –Ω–µ –≤–ª–∞–¥–µ—é—â–∏–µ —Ä–µ—Å—É—Ä—Å–∞–º–∏, –æ—Å—Ç–∞—é—Ç—Å—è –¥–æ—Å—Ç—É–ø–Ω—ã –ø–æ—Å–ª–µ move:

[source,rust]
----
let x = 1;
let y = x;
let z = x;
assert_eq!(y, z);
----

== Copy

–ê–≥—Ä–µ–≥–∞—Ç—ã –∏–∑ `Copy` –æ–±—ä–µ–∫—Ç–æ–≤ —Ç–æ–∂–µ `Copy`:

[subs=+quotes]
[source,rust]
----
#[derive(Clone, **Copy**)]
struct Point { x: f64, y: f64 }

(Point, Point)

[Point; 1024] // –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –º–æ–∂–Ω–æ, –Ω–æ –Ω–µ —Å—Ç–æ–∏—Ç
----

* `Box<T>` –∏ `Vec<T>` –Ω–µ `Copy` -- –¥–æ–ª–∂–Ω—ã –æ—Å–≤–æ–±–æ–∂–¥–∞—Ç—å –ø–∞–º—è—Ç—å

[.title-slide]
== –°—Å—ã–ª–∫–∏


== –ñ–∏–∑–Ω—å –±–µ–∑ —Å—Å—ã–ª–æ–∫

[source,rust,subs=+quotes]
----
fn print_vec(xs: Vec<i32>) {
    for x in xs {
        println!("{}", x);
    }
}

fn main() {
    let xs = vec![1, 2, 3];
    print_vec(xs);   // ok
    [.hl-error]##print_vec(xs)##;   // value used after move
}
----

== –ñ–∏–∑–Ω—å —Å —Å—Å—ã–ª–∫–∞–º–∏

[source,rust,subs=+quotes]
----
fn print_vec(xs: **&**Vec<i32>) {
    for x in xs {
        println!("{}", x);
    }
}

fn main() {
    let xs = vec![1, 2, 3];
    print_vec(**&**xs);  // ok
    print_vec(**&**xs);  // ok
}
----

`&` –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–µ –º–µ–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤–ª–∞–¥–µ–Ω–∏—è

== –í–ñ —Å—Å—ã–ª–∫–∏

- —Å—Å—ã–ª–∫–∞ (`&T` –∏–ª–∏ [.language-rust]`&mut T`) -- —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ–±—ä–µ–∫—Ç
- –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ **—Å—Å—ã–ª–∫–∏** -- –≤—Ä–µ–º—è, –∫–æ–≥–¥–∞ —Å—Å—ã–ª–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

[subs=+quotes]
[source,rust]
----
fn main() {
    let x = 1;
    let r = &x;          // ^
    foo(r);              // | –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ &r
    println!("{}", *r);  // v
}

fn foo(r: &i32) { // lifetime **–±–æ–ª—å—à–µ** —á–µ–º —Ñ—É–Ω–∫—Ü–∏—è
}
----

== –°—Å—ã–ª–∫–∏ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è

- –í–ñ –æ–±—ä–µ–∫—Ç–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ, —á–µ–º –í–ñ –ª—é–±–æ–π —Å—Å—ã–ª–∫–∏ –Ω–∞ –Ω–µ–≥–æ

[source,rust]
----
let x = 1;
let r: &i32;
{
    let y = 2;
    r = &x;  // ok
}
println!("{}", *r);
----

== –°—Å—ã–ª–∫–∏ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏—è

- –í–ñ –æ–±—ä–µ–∫—Ç–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ, —á–µ–º –í–ñ –ª—é–±–æ–π —Å—Å—ã–ª–∫–∏ –Ω–∞ –Ω–µ–≥–æ

[subs=+quotes]
[source,rust]
----
let x = 1;
let r: &i32;
{
    let y = 2;
    r = [.hl-error]##&y##;  // borrowed value does not live long enough
}
println!("{}", *r);
----

== –ò–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –í–ñ

[source,rust]
----
fn main() {
    let x = 1;
    let r: &i32;
    {
        let y = 2;
        r = f(&x, &y); // ???
    }
    println!("{}", *r);
}

fn f(x: &i32, y: &i32) -> &i32 {
    ...
}
----

–ù–µ –ø–æ—Å–º–æ—Ç—Ä–µ–≤ –≤ —Ç–µ–ª–æ `f`, –Ω–µ –ø–æ–Ω—è—Ç—å, –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω –ª–∏ –∫–æ–¥.

== –ò–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –í–ñ

[subs=+quotes]
[source,rust]
----
fn main() {
    let x = 1;
    let r: &i32;
    {
        let y = 2;
        r = f(&x, &y); // ok
    }
    println!("{}", *r);
}

fn f<'a, 'b>(x: &'a i32, y: &'b i32) -> &'a i32 {
   [.hl-error]## y ## // parameter and the return type are declared
       // with different lifetimes
}
----

–ú–æ–∂–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–ª–æ –∏ –≤—ã–∑–æ–≤ `f` –ø–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏!

== –°—Å—ã–ª–∫–∏ –Ω–∞ –ø–æ–¥–æ–±—ä–µ–∫—Ç—ã

[source,rust,subs="quotes"]
----
struct S { value: i32 }

fn main() {
    let r: &i32;
    {
        let s = S { value: 92 };
        let rs: &S = [.hl-error]##&s##; // does not live long enough
        r = f(rs);
    }
    println!("{}", *r); // borrowed value needs to live until here
}

fn f<'a>(s: &'a S) -> &'a i32 {
    &s.value // ok!
}
----

== –ß—Ç–æ —Ç–∞–∫–æ–µ 'a?

[source,rust]
----
fn f<'a>(s: &'a S) -> &'a i32 {
    &s.value
}
----

- –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —Å—Å—ã–ª–æ–∫ –Ω–∞–∑–Ω–∞—á–∞—é—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º
- [.language-rust]`'a` —ç—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ (–í–ñ `&S` –∏ `&i32` —Ä–∞–≤–Ω—ã)

- borrow checking -- —Ä–µ—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É —É—Ä–∞–≤–Ω–µ–Ω–∏–π –Ω–∞ lifetime:
    * –∑–∞–¥–∞–Ω–Ω—ã–µ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º–∏ –í–ñ (—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –∏–ª–∏ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ)
    * lifetime —Å—Å—ã–ª–∫–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –µ—ë –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    * lifetime —Å—Å—ã–ª–∫–∏ –º–µ–Ω—å—à–µ, —á–µ–º lifetime –æ–±—ä–µ–∫—Ç–∞
    * ...

== –ó–∞–º–æ—Ä–æ–∑–∫–∞

[source,rust]
----
struct Wrapper {
    value: Box<i32>,
}

fn main() {
    let w = Wrapper { value: Box::new(92) };
    let r: &i32 = &*w.value;
    w.value = Box::new(62);
    println!("{}", *r); // dangling reference
}
----

== –ó–∞–º–æ—Ä–æ–∑–∫–∞

[source,rust]
----
struct Wrapper {
    value: Box<i32>,
}

fn main() {
    let w = Wrapper { value: Box::new(92) };
    let r: &i32 = &*w.value;
    w = Wrapper { value: Box::new(62) }
    println!("{}", *r); // dangling reference
}
----

== –ó–∞–º–æ—Ä–æ–∑–∫–∞

[source,rust]
----
struct Wrapper {
    value: Box<i32>,
}

fn main() {
    let w = Wrapper { value: Box::new(92) };
    let r: &i32 = &*w.value;
    w = Wrapper { value: Box::new(62) }
    println!("{}", *r); // dangling reference
}
----

–ê–∫—Ç–∏–≤–Ω–∞—è —Å—Å—ã–ª–∫–∞ –∑–∞–º–æ—Ä–∞–∂–∏–≤–∞–µ—Ç –æ–±—ä–µ–∫—Ç –∏ –≤—Å–µ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã: –∏—Ö –Ω–µ–ª—å–∑—è
–º–µ–Ω—è—Ç—å.

== –ó–∞–º–æ—Ä–æ–∑–∫–∞

[source,rust]
----
struct Wrapper {
    value: Box<i32>,
}

fn main() {
    let w = Wrapper { value: Box::new(92) };
    let r: &i32 = &*w.value;
    if w.value > 640 { println!("enough"); }
    println!("{}", *r); // ok
}
----

–°–º–æ—Ç—Ä–µ—Ç—å –º–æ–∂–Ω–æ!

== mut

[source,rust]
----
struct Wrapper {
    value: Box<i32>,
}

fn main() {
    let w = Wrapper { value: Box::new(92) };
    let r: &i32 = &*w.value;
    f(&w);
    println!("{}", *r);
}

fn f(w: &Wrapper) {
    ...
}
----

–•–æ—Ç–∏–º –Ω–µ —Å–º–æ—Ç—Ä–µ—Ç—å –≤ —Ç–µ–ª–æ `f` -- –Ω—É–∂–µ–Ω —Å–ø–æ—Å–æ–± –ø–æ–Ω—è—Ç—å, –∏–∑–º–µ–Ω—è–µ—Ç –ª–∏ `f` –∞—Ä–≥—É–º–µ–Ω—Ç.

== mut

[subs=+quotes]
[source,rust,linenums]
----
struct Wrapper {
    value: Box<i32>,
}

fn main() {
    let mut w = Wrapper { value: Box::new(92) };
    // cannot borrow `w` as mutable
    // because `*w.value` is also borrowed as immutable
    let r: &i32 = [.hl-error]##&*w.value##;
    f([.hl-error]##&mut w##);
    println!("{}", *r);
}

fn f(w: &mut Wrapper) {
    w.value = Box::new(62); // ok
}
----

== Shared ^ Mutable

- –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ –Ω—É–∂–Ω–∞ [.language-rust]`&mut` —Å—Å—ã–ª–∫–∞
- `&` —Å—Å—ã–ª–∫–∏ –∑–∞–º–æ—Ä–∞–∂–∏–≤–∞—é—Ç –æ–±—ä–µ–∫—Ç

.–ü—Ä–∞–≤–∏–ª–æ "shared XOR mutable"
[NOTE]
–õ–∏–±–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è [.language-rust]`&mut` —Å—Å—ã–ª–∫–∞, –ª–∏–±–æ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
`&` —Å—Å—ã–ª–æ–∫

== –ü—Ä–∏–º–µ—Ä

.main.cpp
[source,cpp]
----
std::vector<int> xs = {1, 2, 3};
auto& x = xs[0];
xs.push_back(4);
std::cout << x; // UB!
----

== –ü—Ä–∏–º–µ—Ä

.main.rs
[source,rust]
----
let mut xs = vec![1, 2, 3];
let x = &xs[0];
xs.push(4);
println!("{}", x);
----

[source]
----
error[E0502]: cannot borrow `xs` as mutable because
it is also borrowed as immutable
 --> main.rs:4:1
  |
3 | let x = &xs[0];
  |          -- immutable borrow occurs here
4 | xs.push(4);
  | ^^ mutable borrow occurs here
...
7 | }
  | - immutable borrow ends here
----

[.two-col]
== –°—Å—ã–ª–∫–∏ –≤ C++ –∏ Rust

.C++
- —Å–æ–∑–¥–∞—é—Ç—Å—è –Ω–µ—è–≤–Ω–æ
- –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ø–µ—Ä–≤–æ–∫–ª–∞—Å—Å–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏ (`std::reference_wrapper`)
- –Ω–µ –≤—Å–µ–≥–¥–∞ –≤–∞–ª–∏–¥–Ω—ã

.Rust
- —Ç—Ä–µ–±—É—é—Ç —è–≤–Ω—ã—Ö `&`/[.language-rust]`&mut` –∏ `*`
- –æ–±—ã—á–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
+
[source,rust]
----
let x = 1;
let y = 2;
let mut r: &i32 = &x;
r = &y;
----
- –≤—Å–µ–≥–¥–∞ –≤–∞–ª–∏–¥–Ω—ã

== –ò—Ç–æ–≥–æ

- —É –∫–∞–∂–¥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –µ—Å—Ç—å –æ–¥–∏–Ω –≤–ª–∞–¥–µ–ª–µ—Ü (=> –¥–µ—Ä–µ–≤–æ –≤–ª–∞–¥–µ–Ω–∏—è)
- `&` –∏ [.language-rust]`&mut` —Å—Å—ã–ª–∫–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–±—ä–µ–∫—Ç –±–µ–∑ –≤–ª–∞–¥–µ–Ω–∏—è
- [.language-rust]`mut` –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–µ–Ω—è—Ç—å –æ–±—ä–µ–∫—Ç
- [.language-rust]`&mut` —Å—Å—ã–ª–∫–∞ –≤—Å–µ–≥–¥–∞ –æ–¥–Ω–∞
- –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –í–ñ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏—è –º–µ–∂–¥—É —Å—Å—ã–ª–∫–∞–º–∏
- –í–ñ –¥–ª—è —Å—Å—ã–ª–æ–∫ –≤—ã–±–∏—Ä–∞—é—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º
- –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π –∫–æ–¥ **–Ω–µ –∑–∞–≤–∏—Å–∏—Ç** –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –í–ñ (parametricity)
- 80% –ø—Ä–∞–≤–¥—ã

[.title-slide]
== –í—ã—Ä–∞–∂–µ–Ω–∏—è



[.centered]
== –í—ã—Ä–∞–∂–µ–Ω–∏—è

- C —Å –∞—Ä–æ–º–∞—Ç–æ–º ML
- –ø–æ—á—Ç–∏ –≤—Å–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ -- –≤—ã—Ä–∞–∂–µ–Ω–∏—è

== –ë–ª–æ–∫–∏

`{}` -- –≤—ã—Ä–∞–∂–µ–Ω–∏–µ

[source,rust]
----
1 + { let x = 2; x * 2 }
----

–ë–ª–æ–∫ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π (statement), –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö `;`

–ó–Ω–∞—á–µ–Ω–∏–µ –±–ª–æ–∫–∞ -- –∑–Ω–∞—á–µ–Ω–∏–µ —Ö–≤–æ—Å—Ç–æ–≤–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è.

[source,rust]
----
let i: i32 = { 1  };
let i: ()  = { 1; };
----

–¢–æ—á–∫–∏ —Å –∑–∞–ø—è—Ç–æ–π –∏–º–µ—é—Ç –∑–Ω–∞—á–µ–Ω–∏–µ!

[.centered]
== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–ª–æ–∫–æ–º

====
[source,rust]
----
// –õ–∏—à–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –≤–∏–¥–Ω—ã —Å–Ω–∞—Ä—É–∂–∏
let omelet = {
    let eggs = get_eggs(&mut refrigerator, 3);
    let bacon = open_bacon(&mut refrigerator);
    fry(eggs, bacon)
};
----
====

== if

[source,rust]
----
let res = if condition1 {
    expr1;
    expr2
} else if condition2 {
    expr3
} else {
    expr4
};
----

* –Ω–µ—Ç `()` –≤–æ–∫—Ä—É–≥ —É—Å–ª–æ–≤–∏—è
* `{}` –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
* `else if` -- –æ—Å–æ–±—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å, –Ω–µ—Ç dangling else problem
* –µ—Å–ª–∏ –Ω–µ—Ç –±–ª–æ–∫–∞ `else`, –∑–Ω–∞—á–µ–Ω–∏–µ -- `()`

[.centered]
== if

[source,rust,subs="quotes"]
----
fn main() {
    if true {
        [.hl-error]#92#  // expected (), found integral variable
    }
}
----

[.centered]
== if

[source,rust,subs="quotes"]
----
fn main() {
    if true {
        92; // ok!
    }
}
----

== while

[source,rust]
----
while condition {
    body // <- –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ç–∏–ø–∞ ()
}

let x: () = while false {};
----

== break –∏ continue

[source,rust]
----
while true  {
    if cond1 {
        continue;
    }
    if cond2 {
        break;
    }
}

'outer: while cond1 {
    while cond2 {
        break 'outer;
    }
}
----

== loop

–°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
[source,rust]
----
loop {
    body
}
----

NOTE: `[.hl-kw]#loop# {}` –∏ [.language-rust]`while true {}` –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –ø—Ä–æ
–ø–æ—Ç–æ–∫ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

[.two-col]
== loop

[source,rust,subs="quotes"]
----
let uninit;
while true {
    if condition {
        uninit = 92;
        break;
    }
}
pritnln!("{}", [.hl-error]##uninit##);
----

[source,rust,subs="quotes"]
----
let init;
loop {
    if condition {
        init = 92;
        break;
    }
}
pritnln!("{}", init); // ok
----

== loop

[source,rust]
----
let init;

if condition {
    init = 92;
} else {
    loop {}
}
println!("{}", init); // ok!
----

[.centered]
== –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è

* –≤ C/C++ –¥–æ—Å—Ç—É–ø –∫ –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π -- UB
* –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä—è—á–µ—Ç –±–∞–≥–∏

== {empty} !

[source,rust]
----
let x: ! = loop {};
----

* –Ω–µ–Ω–∞—Å–µ–ª—ë–Ω–Ω—ã–π —Ç–∏–ø

* –º–æ–∂–µ—Ç –≤—ã—Å—Ç—É–ø–∞—Ç—å –≤ —Ä–æ–ª–∏ –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ —Ç–∏–ø–∞
+
[source,rust]
----
let x: u32 = loop {};
----

* –ø–æ–∫–∞ –µ—â—ë –Ω–µ –Ω–∞—Å—Ç–æ—è—â–∏–π —Ç–∏–ø


== panic!()

–°–µ–º–µ–π—Å—Ç–≤–æ –º–∞–∫—Ä–æ—Å–æ–≤, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏—Ö `!`:

* [.language-rust]`panic!("something went wrong")` -- –¥–ª—è —Å–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –æ –±–∞–≥–∞—Ö
* [.language-rust]`unimplemented!()` -- –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä –¥–ª—è –µ—â—ë –Ω–µ –Ω–∞–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞
+
[source,rust]
----
if complex_condition {
    complex_logic
} else {
    unimplemented!()
}
----
* [.language-rust]`unreachable!()` -- –º–∞—Ä–∫–µ—Ä –¥–ª—è "–Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã—Ö" —É—Å–ª–æ–≤–∏–π

[.centered]
== break —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º

[source,rust]
----
let init: i32 = loop {
    if condition {
        break 92;
    }
};
----

== for

[source,rust]
----
for x in vec![1, 2, 3] {
    println!("x = {}", x);
}

let xs  = vec![1, 2, 3];
for i in 0..xs.len() {
    let x = xs[i];
    pritnln!("x = ", x);
}
----

–ü—Ä–æ—Ç–æ–∫–æ–ª –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ -- –¥–∞–ª—å—à–µ –≤ –∫—É—Ä—Å–µ

== ranges

[source,rust]
----
let bounded: std::ops::Range<i32> = 0..10;
let from = 0..;
let to = ..10;
let full = ..;
let inclusive = 0..=9;

for i in (0..10).step_by(2) {
    println!("i = {}", i);
}
----

–üo `lo..hi` –∏ `lo..` –º–æ–∂–Ω–æ –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è

== –ï—â—ë —Ä–∞–∑ –æ `;`

`;` –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç expression –≤ statement

{empty} +

–ü–æ—Å–ª–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–π-–±–ª–æ–∫–æ–≤ `;` –Ω–µ –Ω—É–∂–Ω–∞:
[source,rust]
----
{
    if x == 0 {
        println!("zero");
    }      // statement

    { 0; } // statement

    if true { 92 } else { 62 } // expression!
}
----

== –ï—â—ë —Ä–∞–∑ –æ `;`

–ü–æ—Å–ª–µ [.language-rust]`let` `;` –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞:
[source,rust,subs="quotes"]
----
let s = if x > 0 {
    "positive"
} else {
    "negative"
}**;**
----


== –î–≤–∞ —Å–ª–æ–≤–∞ –æ —Ñ—É–Ω–∫—Ü–∏—è—Ö

[source,rust]
----
fn hypot(x: f64, y: f64) -> f64 {
    let x_squared = x * x;
    let y_squared = y * y;
    (x_squared + y_squared).sqrt()
}
----

* —Ç–∏–ø—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã
* –Ω–µ—Ç –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∏
* [.language-rust]`fn main {}` == [.language-rust]`+fn main() -> ()+`
* —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏ -- –±–ª–æ–∫
* [.hl-kw]`return` –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω
* [.language-rust]`+fn diverge() -> ! { loop {} }+`

[.centered]
== Quiz

[source,rust]
----
fn foo() {
    let x = return;
}
----

[NOTE.question]
–ö–∞–∫–æ–π —Ç–∏–ø —É `x`?

[.title-slide]
== –ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö


== –°—Ç—Ä—É–∫—Ç—É—Ä—ã

[source,rust]
----
#[derive(Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

let p1 = Point { x: 1.0, y: 2.0 };

let p2 = Point {
    x: 2.0,
    .. p1
};

assert_eq!(p2.x, p2.y);
----

== –ú–µ—Ç–æ–¥—ã

[source,rust]
----
struct Point { x: f64, y: f64 }

impl Point {
    fn distance_from_origin(&self) -> f64 {
        (self.x * self.x + self.y * self.y).sqrt()
    }
}
----

* [.language-rust]`self` -- —è–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è `this`
* [.language-rust]`&self` -- –ø–µ—Ä–µ–¥–∞—á–∞ –ø–æ —Å—Å—ã–ª–∫–µ

== –ú–µ—Ç–æ–¥—ã

[source,rust]
----
struct Point { x: f64, y: f64 }

impl Point {
    fn scale(&mut self, factor: f64) {
        self.x *= factor;
        self.y *= factor;
    }
}
----

* [.language-rust]`&mut self` -- –ø–µ—Ä–µ–¥–∞—á–∞ –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ

== –ú–µ—Ç–æ–¥—ã

[source,rust]
----
struct Point { x: f64, y: f64 }

impl Point {
    fn consume(self) {
    }
}
----

* [.language-rust]`self` -- –ø–µ—Ä–µ–¥–∞—á–∞ –≤–ª–∞–¥–µ–Ω–∏—è

== –ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

[source,rust]
----
struct Point { x: f64, y: f64 }

impl Point {
    fn origin() -> Point {
        Point { x: 0.0, y: 0.0 }
    }
}

let p = Point::origin();
assert_eq!(
    p.distance_from_origin(),
    0.0,
);
----

== Deref

[source,rust]
----
fn foo(mut p: Point) {
    p.scale(2.0);
    let d1 = p.distance_from_origin();
    let boxed = Box::new(p);
    let d2 = boxed.distance_from_origin();
    assert_eq!(d1, d2);
}
----

TIP: –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç `&`, [.language-rust]`&mut` –∏ `*`

== Deref

[source,rust,subs=+quotes]
----
fn foo(mut p: Point) {


    let boxed = Box::new(p);
    let d2 = **(&*boxed)**.distance_from_origin();

}
----

TIP: –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç `&`, [.language-rust]`&mut` –∏ `*`

== –°—Ç—Ä—É–∫—Ç—É—Ä—ã-–∫–æ—Ä—Ç–µ–∂–∏


[source,rust]
----
struct Point(f64, f64);

impl Point {
    fn origin() -> Point {
        Point(0.0, 0.0)
    }
    fn dist(self, other: Point) -> f64 {
        let Point(x1, y1) = self;
        let Point(x2, y2) = other;
        ((x1 - x2).powi(2) + (y1 - y2).powi(2)).sqrt()
    }
}

let p = Point(0.0, 1.0);
assert_eq!(p.0, 0.0);
----

== **–ü–∞—Ç—Ç–µ—Ä–Ω** newtype

[source,rust]
----
struct Kilometers(f64);
struct Miles(f64);
----

* –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏ —Ç–∞–∫–æ–µ –∂–µ, –∫–∞–∫ –∏ —É –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Ç–∏–ø–∞
* –ù–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è—Ö
* –ù–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ–Ω–≤–µ—Ä—Å–∏–∏/–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –º–µ—Ç–æ–¥–æ–≤

== **Z**ero **S**ized **T**ypes

[source,rust]
----
struct Tag;

let t = Tag;
assert!(std::mem::size_of::<Tag>() == 0);
assert!(std::mem::size_of::<(Tag, Tag)>() == 0);
assert!(std::mem::size_of::<[Tag; 1024]>() == 0);
assert!(std::mem::size_of::<()>() == 0);
----

TIP: ZST —Å—É—â–µ—Å—Ç–≤—É—é—Ç —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–∏–ª—è—Ü–∏–∏ +
üëâ zero cost abstraction!

== Type Tags

[source,rust]
----
struct Kilometers;
struct Miles;

struct Distance<M> {
    amount: f64,
    metric: M,
}

let d1: Distance<Kilometers> = Distance {
    amount: 92.0,
    metric: Kilometers,
};
let d2: Distance<Miles> = Distance {
    amount: 92.0,
    metric: Miles,
};
----

== –í–∏–¥—ã —Å—Ç—Ä—É–∫—Ç—É—Ä

struct::
[source,rust]
----
struct Point { x: f64, y: f64 }
----

tuple struct::
[source,rust]
----
struct Point(f64, f64);
----

newtype (tuple) struct::
[source,rust]
----
struct Point1D(f64);
----

unit struct::
[source,rust]
----
struct ThePoint; // ZST
----

== **D**ynamically **S**ized **T**ypes

* `[i32; 4]` -- —á–µ—Ç—ã—Ä–µ —á–∏—Å–ª–∞
* `&[i32; 4]` -- –∞–¥—Ä–µ—Å—Å –≤ –ø–∞–º—è—Ç–∏, –≥–¥–µ –ª–µ–∂–∞—Ç —á–µ—Ç—ã—Ä–µ —á–∏—Å–ª–∞
* `[i32]` -- n —á–∏—Å–µ–ª
+
[source]
----
mem::size_of::<[i32]>();
^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
----
* `&[i32]` -- —É–∫–∞–∑–∞—Ç–µ–ª—å + –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, fat pointer
+
[source,rust]
----
assert_eq!(
    mem::size_of::<&[i32]>(),
    mem::size_of::<usize>() * 2,
)
----

== Slices

* `&[T]` -- —Å–ª–∞–π—Å
+
[source,rust]
----
fn print_slice(xs: &[i32]) {
    for idx in 0..xs.len() {
        println!("{}", xs[i]);
    }
}
----
* **–≤—Å–µ–≥–¥–∞** –∑–Ω–∞–µ—Ç —Å–≤–æ—é –¥–ª–∏–Ω—É
* –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É –ø—Ä–æ–≤–µ—Ä—è—Ç –≤—ã—Ö–æ–¥ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—É
* –Ω–µ–ª—å–∑—è –æ—Ç–∫–ª—é—á–∏—Ç—å —Ñ–ª–∞–≥–æ–º –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞
* `&[T]` –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∏–∑ `&[T; N]` –∏–ª–∏ `Vec<N>`


== Enums

[source,rust]
----
enum Shape {
    Circle {
        center: Point,
        radius: f64,
    },
    Square {
        bottom_left: Point,
        top_right: Point,
    },
}
----

== Enums

[source,rust]
----
impl Shape {
    fn circle(center: Point, radius: f64) -> Shape {
        Shape::Circle { center, radius }
    }
    fn area(&self) -> f64 {
        match self {
            Shape::Circle { radius, .. } => {
                std::f64::consts::PI * radius * radius
            }
            Shape::Square { bottom_left, top_right } => {
                unimplemented!()
            }
        }
    }
}
----

== Enums

[source,rust]
----
enum Expr {
    Negation(Box<Expr>),
    BinOp { lhs: Box<Expr>, rhs: Box<Expr> },
    Unit,
}
----

* –≤–∞—Ä–∏–∞–Ω—Ç—ã [.language-rust]`enum` –±—ã–≤–∞—é—Ç —Ç–∞–∫–∏–µ –∂–µ, –∫–∞–∫ –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
* –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ `**Expr::**BinOp { lhs, rhs}`, +
  **–Ω–æ** –º–æ–∂–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç: `use Expr::BinOp`
* `mem::size_of` -- —Ä–∞–∑–º–µ—Ä —Å–∞–º–æ–≥–æ –±–æ–ª—å—à–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ + –¥–∏—Å–∫—Ä–∏–º–∏–Ω–∞–Ω—Ç
* —Ä–∞–∑–º–µ—Ä –æ–±—ä–µ–∫—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–º

== –ü–æ–ª–µ–∑–Ω—ã–µ enum—ã

[source,rust]
----
// use std::cmp::Ordering;
enum Ordering {
    Less,
    Equal,
    Greater,
}

fn binary_search(xs: &[i32], x: i32) -> bool {
    if xs.is_empty() { return false; }
    let mid = xs.len() / 2;
    let subslice = match xs[mid].cmp(&x) {
        Ordering::Less => &xs[mid + 1..],
        Ordering::Equal => return true,
        Ordering::Greater => &xs[..mid],
    };
    binary_search(subslice, x)
}
----

== –ü–æ–ª–µ–∑–Ω—ã–µ enum—ã

[source,rust]
----
enum Option<T> {
    Some(T),
    None,
}

fn foo(xs: &[i32]) {
    match xs.get(92) {
        Some(value) => ...,
        None => panic!("out of bounds access")
    }
}
----

NOTE: –ò–º–µ–Ω–∞ `None` –∏ `Some` –¥–æ—Å—Ç—É–ø–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

== –ü–æ–ª–µ–∑–Ω—ã–µ enum—ã

[source,rust]
----
enum Result<T, E> {
    Ok(T),
    Err(E),
}
----

[source,rust,subs=+quotes]
----
impl<T> [T] {
    pub fn binary_search(&self, x: &T) -> **Result**<usize, usize>
    where
        T: Ord
    {
        self.binary_search_by(|p| p.cmp(x))
    }
}
----

== Newtype Variant

[source,rust]
----
enum Expr {
    BinOp {
        lhs: Box<Expr>,
        rhs: Box<Expr>,
        op: Op,
    },
    If {
        cond: Box<Expr>,
        then_branch: Box<Expr>,
        else_branch: Box<Expr>,
    },
}
----

NOTE: `BinOp` –∏ `If` —Ç–∏–ø–∞–º–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è

[.two-col]
== Newtype Variant

[source,rust]
----
enum Expr {
    BinOp(BinOp),
    If(If)
}

struct BinOp {
    lhs: Box<Expr>,
    rhs: Box<Expr>,
    op: Op,
}

struct If {
    cond: Box<Expr>,
    then_branch: Box<Expr>,
    else_branch: Box<Expr>,
}
----

[.centered]
== Void

[.big.text-center]
[source,rust]
----
enum Void {}
----

== Void

[source,rust]
----
enum Void {}

fn foo(void: Void) -> Vec<Point> {
    match void {
    }
}
----

* —ç–Ω—É–º –±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ -- –∞–Ω–∞–ª–æ–≥ `!`
* –≥–∞—Ä–∞–Ω—Ç–∏—è, —á—Ç–æ –∫–æ–¥ –Ω–µ –¥–æ—Å—Ç–∏–∂–∏–º
* `size_of::<Void>() == 0` [.big]#üòï#

== Result

* `Result<T, Void> ==  T`
+
[source,rust]
----
fn extract(result: Result<Spam, Void>) -> Spam {
    match result {
        Ok(spam) => spam,
        Err(void) => match void {},
    }
}
----

[NOTE.question]
–ù–∞ —á—Ç–æ –ø–æ—Ö–æ–∂ `Result<(), ()>`?

== –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏

* –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏ –Ω–µ —Å–ø–µ—Ü–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ
* –∫–æ–º–ø–∏—è–ª—Ç–æ—Ä –º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ—Ç –ø–∞–¥–¥–∏–Ω–≥ (–µ—Å—Ç—å `#[repr]` –∞—Ç—Ä–∏–±—É—Ç—ã)
* –¥–∏—Å–∫—Ä–∏–º–∏–Ω–∞–Ω—Ç –º–æ–∂–µ—Ç –ø—Ä—è—Ç–∞—Ç—å—Å—è –≤ –Ω–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö –±–∏—Ç–∞—Ö
* –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —á—Ç–æ
+
----
mem::size_of::<Option<&T>>() == mem::size_of::<&T>()
mem::size_of::<Option<Box<T>>>() == mem::size_of::<Box<T>>()
----
* `bool` –∑–∞–Ω–∏–º–∞–µ—Ç 1 –±–∞–π—Ç, —á—Ç–æ–±—ã `&bool` —Ä–∞–±–æ—Ç–∞–ª –≤—Å–µ–≥–¥–∞
* Newtype Variant –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ –æ–±—ã—á–Ω–æ–≥–æ enum –∏–∑-–∑–∞ –ø–∞–¥–¥–∏–Ω–≥–∞ :o)
* –±—ã–≤–∞—é—Ç —Ç–∏–ø—ã "—Å—Ç—Ä–∞–Ω—ã—Ö" —Ä–∞–∑–º–µ—Ä–æ–≤: ZST, DST, uninhabited
