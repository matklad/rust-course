= Rust 2019
–ê–ª–µ–∫—Å–µ–π –ö–ª–∞–¥–æ–≤ <aleksey.kladov@gmail.com>
:icons: font
:lecture: –õ–µ–∫—Ü–∏—è 13: –ú–∞–∫—Ä–æ—Å—ã
:table-caption!:
:example-caption!:

== –ú–∞–∫—Ä–æ—Å—ã

–°–ø–æ—Å–æ–± –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ –Ω–∞–¥ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–æ–º —è–∑—ã–∫–∞

* –º–æ–≥—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç (—Å–≤–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å!)
* –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç (—Ç–æ–ª—å–∫–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å)


NOTE: –ú–∞–∫—Ä–æ—Å—ã –Ω–µ —É—Å–ø–µ–ª–∏ –¥–æ–¥–µ–ª–∞—Ç—å –∫ 1.0, —Ç–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è –Ω–µ –±–µ–∑ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–æ–≤ :-)

[.title-slide]
== Quick Tour

== Macro By Example By Example

[source,rust]
----
struct Function { ... }
struct Const { ... }
struct TypeAlias { ... }

pub enum TraitItem {
    Function(Function),
    Const(Const),
    TypeAlias(TypeAlias),
}
----

Poor man's OOP

== Macro By Example By Example

[source,rust]
----
impl From<Function> for TraitItem {
    fn from(item: Function) -> TraitItem {
        TraitItem::Function(item)
    }
}

impl From<Const> for TraitItem {
    ...
}

impl From<TypeAlias> for TraitItem {
    ...
}

----

CAUTION: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞!

== Macro By Example By Example

[source,rust]
----
macro_rules! impl_froms {
    ($e:ident : $($v:ident),* ) => {
        $(
            impl From<$v> for $e {
                fn from(it: $v) -> $e { $e::$v(it) }
            }
        )*
    }
}

pub enum TraitItem {
    Function(Function),
    Const(Const),
    TypeAlias(TypeAlias),
}
impl_froms!(TraitItem: Function, Const, TypeAlias);
----

== !

[source,rust]
----
macro_rules! impl_froms {
    ($e:ident : $($v:ident),* ) => {
        $(
            impl From<$v> for $e {
                fn from(it: $v) -> $e { $e::$v(it) }
            }
        )*
    }
}
impl_froms!(TraitItem: Function, Const, TypeAlias);
----

* `impl_froms` -- –∏–º—è –º–∞–∫—Ä–æ—Å–∞
* `+( ... ) =>+` -- –ø–∞—Ç—Ç–µ—Ä–Ω
* `$e:ident` -- –º–∞–∫—Ä–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, –º–∞—Ç—á–∏—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä
* `$($v:ident),*` --  –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã —á–µ—Ä–µ–∑ `,`
* `+=> { ... }+` -- —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–∫—Ä—ã—Ç–∏—è –º–∞–∫—Ä–æ—Å–∞

== Token Trees

–°–∏–Ω—Ç–∞–∫—Å–∏—Å –≤—ã–∑–æ–≤–∞ –º–∞–∫—Ä–æ—Å–æ–≤:

[source,rust]
----
an::path! opt_name { token_tree }
----


`token_tree` -- –ª—é–±–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–æ–≤ Rust –≥–¥–µ `()`, `[]` –∏ `{}`
—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω—ã

–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã –º–∞–∫—Ä–æ—Å–∞ -- —Ç–æ–∂–µ token tree

–ú–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —è–∑—ã–∫–∞!

[source,rust]
----
format!(
    "my name is {name}, my father's name is also {name}",
    name = "John"
);
----

[.centered]
== !

`macro_rules` —ç—Ç–æ —Ç–æ–∂–µ –º–∞–∫—Ä–æ—Å!

[source,rust]
----
macro_rules! impl_froms {
    ($e:ident : $($v:ident),* ) => {
        $(
            impl From<$v> for $e {
                fn from(it: $v) -> $e { $e::$v(it) }
            }
        )*
    }
}
----

–ù–µ –Ω—É–∂–Ω–æ –∏–∑–æ–±—Ä–µ—Ç–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ —è–∑—ã–∫–∞

== –ü—Ä–∏–º–µ—Ä—ã

`format!`, `println!`, `log::info!` -- –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –±–µ–∑
—Å–ª–æ–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã —Ç–∏–ø–æ–≤

`vec!` -- –ª–∏—Ç–µ—Ä–∞–ª –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –±–µ–∑ –Ω–æ–≤–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ / vararg —Ñ—É–Ω–∫—Ü–∏–π

`try!` -- —Å—Ç–∞—Ä–∞—è –≤–µ—Ä—Å–∏—è `?`: [.language-rust]`try!(File::create("hello.txt"))`, –æ—Ç–ª–æ–∂–∏–ª–∏ –¥–∏–∑–∞–π–Ω
—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞


NOTE: Lazy language design!

== Vs. C

–í C –º–∞–∫—Ä–æ—Å—ã —Ä–∞—Å–∫—Ä—ã–≤–∞—é—Ç—Å—è –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–º, –∞ –Ω–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º

[source,cpp]
----
#define squared(a) a * a

int main(void) {
    squared(1 + 1); // 1 + 1 * 1 + 1
    return 0;
}
----

–ú–æ–∂–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–º–µ–Ω—è—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —è–∑—ã–∫–∞

[source,cpp]
----
#define begin {
#define end }
----

== Vs. C

Rust —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç token trees

[source,rust]
----
macro_rules! squared {
    ($e:expr) => { $e * $e }
}

fn main() {
    squared!(1 + 1); // [1 + 1] * [1 + 1]
}
----

–¢–∞–∫ –∫–∞–∫ –º–∞–∫—Ä–æ—Å—ã —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏ –≤—ã–¥–µ–ª–µ–Ω—ã (`!` + –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å–∫–æ–±–æ—á–Ω–∞—è
–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å), –∫–æ–¥ –Ω–∞ Rust –º–æ–∂–Ω–æ –ø–∞—Ä—Å–∏—Ç—å, –Ω–µ —Ä–∞—Å–∫—Ä—ã–≤–∞—è –º–∞–∫—Ä–æ—Å–æ–≤.

== Vs. Scala

–í Rust –∞—Ä–≥—É–º–µ–Ω—Ç –º–∞–∫—Ä–æ—Å–∞ -- –ø–æ—á—Ç–∏ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–æ–≤

–í Scala -- –≤—ã—Ä–∞–∂–µ–Ω–∏–µ +
=> —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –º–µ–Ω—å—à–µ, –Ω–æ IDE –ª–µ–≥—á–µ

{empty} +

–í Rust —Ä–∞—Å–∫—Ä—ã—Ç–∏–µ –º–∞–∫—Ä–æ—Å–æ–≤ -- —Å—Ç—Ä–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ

–í Scala –º–∞–∫—Ä–æ—Å—ã –º–æ–≥—É—Ç —Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —Ç–∏–ø—ã +
=> –±–æ–ª—å—à–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π, –Ω–æ IDE —Ç—è–∂–µ–ª–µ–µ

== Vs. Lisp

–î–µ—Ä–µ–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ -- –ø–æ—á—Ç–∏ S-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ

**–ú–æ–∂–Ω–æ** –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å –¥–µ—Ä–µ–≤—å—è —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º –∫–æ–¥–æ–º

–ù–µ–ª—å–∑—è –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π –∫–æ–¥ –≤–æ –≤—Ä–µ–º—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (–Ω–µ—Ç eval)

[.title-slide]
== Macro By Example

== –í–∏–¥–∏–º–æ—Å—Ç—å

–°–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –¥—Ä—É–≥–∏–µ –ø—Ä–∞–≤–∏–ª–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏: –º–∞–∫—Ä–æ—Å –≤–∏–¥–µ–Ω "–ø–æ—Å–ª–µ" –æ–±—ä—è–≤–ª–µ–Ω–∏—è

[source,rust]
----
include::code/nop.rs[]
----

== –í–∏–¥–∏–º–æ—Å—Ç—å

–ú–∞–∫—Ä–æ—Å—ã –ª–æ–∫–∞–ª—å–Ω—ã –¥–ª—è –±–ª–æ–∫–æ–≤

[source,rust]
----
fn foo() -> i32 {
    macro_rules! bail {
        () => { return 92 }
    }

    if condition {
        bail!();
    }
}
// —Ç—É—Ç `bail` –Ω–µ –≤–∏–¥–Ω–æ
----

== –í–∏–¥–∏–º–æ—Å—Ç—å

–ú–∞–∫—Ä–æ—Å—ã –ª–æ–∫–∞–ª—å–Ω—ã –¥–ª—è –º–æ–¥—É–ª–µ–π –±–µ–∑ `#[macro_use]`

[source,rust]
----

mod foo {
    macro_rules! m1 { () => (()) }
}


#[macro_use]
mod bar {
    macro_rules! m2 { () => (()) }
}

// m2 –≤–∏–¥–µ–Ω, m1 –Ω–µ—Ç
----

== –í–∏–¥–∏–º–æ—Å—Ç—å

–ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –º–∞–∫—Ä–æ—Å–æ–≤ –∏–∑ –¥—Ä—É–≥–∏—Ö –∫—Ä–µ–π—Ç–æ–≤, –æ–±—ã—á–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏

.`./log/src/lib.rs`
[source,rust]
----
#[macro_export]
macro_rules! info {
    ...
}
----

.`./main.rs`
[source,rust]
----
fn main() {
    log::info!("hello, {}", 92);
}
----

== –ü–∞—Ç—Ç–µ—Ä–Ω—ã

[source,rust]
----
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
----

* `item`, `expr`, `ty`, `vis` ...

* {blank}
+
|===
|`+$(...)*+` | `+$(...),*+` | `+$(...)++` | `+$(...)?+`
|===

== –ü–∞—Ç—Ç–µ—Ä–Ω—ã

[source,rust]
----
macro_rules! info {
    (target: $target:expr, $($arg:tt)+) => (
        log!(target: $target, $crate::Level::Info, $($arg)+);
    );
    ($($arg:tt)+) => (
        log!($crate::Level::Info, $($arg)+);
    );
}
----

* –º–æ–∂–Ω–æ –ø–µ—Ä–µ—á–∏—Å–ª–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —á–µ—Ä–µ–∑ `;``
* –≤–∏–¥ —Å–∫–æ–±–æ—á–µ–∫ –Ω–µ –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ
* –º–∞–∫—Ä–æ—Å—ã –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–º–∏
* –≤—Å—ë, —á—Ç–æ –Ω–µ `$`, —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –±—É–∫–≤–∞–ª—å–Ω–æ
* [.language-rust]`$crate` ?

== –ì–∏–≥–∏–µ–Ω–∞

–ú–∞–∫—Ä–æ—Å—ã —á–∞—Å—Ç–∏—á–Ω–æ –≥–∏–≥–∏–µ–Ω–∏—á–Ω—ã–µ

[source,rust]
----
macro_rules! declare_x {
    () => {
        let x = 92;
    }
}

fn main() {
    let x = 62;
    declare_x!();
    println!("{}", x); // 62
}
----

== –ì–∏–≥–∏–µ–Ω–∞

–ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –≤ –º–∞–∫—Ä–æ—Å

[source,rust]
----
macro_rules! declare_var {
    ($var:ident) => {
        let $var = 92;
    }
}

fn main() {
    let x = 62;
    declare_var!(x);
    println!("{}", x); // 92
}
----

== –ì–∏–≥–∏–µ–Ω–∞

–ì–∏–≥–∏–µ–Ω–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ –≤–µ–∑–¥–µ :-(

[source,rust]
----
macro_rules! declare_fn {
    () => {
        fn foo() {}
    }
}

declare_fn!();

fn main() {
    foo(); // Ok :-(
}
----

== –ì—Ä–∞–±–ª–∏

–ì–∏–≥–∏–µ–Ω–∞ + token trees —Ä–µ—à–∞—é—Ç —á–∞—Å—Ç—å –ø—Ä–æ–±–ª–µ–º –º–∞–∫—Ä–æ—Å–æ–≤, –Ω–æ –Ω–µ –≤—Å–µ

[source,rust]
----
macro_rules! min {
    ($x:expr, $y:expr) => {
        if $x < $y { $x } else { $y }
    }
}
----

[NOTE.question]
–í —á—ë–º —Ç—É—Ç –ø—Ä–æ–±–ª–µ–º–∞?

== –ì—Ä–∞–±–ª–∏

[.language-rust]`$x` –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω –¥–≤–∞–∂–¥—ã!

[source,rust]
----
macro_rules! min {
    ($x:expr, $y:expr) => {
        match ($x, $y) {
            (x, y) => if x < y { x } else { y }
        }
    }
}
----

== –ì—Ä–∞–±–ª–∏

.my-crate
[source,rust]
----
#[macro_export]
macro_rules! foo {
    () => {
        use crate::X;
        ...
    }
}
----

.other-crate
[source,rust]
----
use my_crate::foo;

fn main() {
    foo!(); // crate::X –±—É–¥–µ—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞ other_crate
}
----

== –ì—Ä–∞–±–ª–∏

.my-crate
[source,rust]
----
#[macro_export]
macro_rules! foo {
    () => {
        use $crate::X;
        ...
    }
}
----

.other-crate
[source,rust]
----
use my_crate::foo;

fn main() {
    foo!();
}
----


== –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –ú–∞–∫—Ä–æ—Å—ã

* `dbg!` -- –Ω–∞–ø–µ—á–∞—Ç–∞—Ç—å –∏ –≤–µ—Ä–Ω—É—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è: +
 [.language-rust]`dbg!(foo.bar()).baz`

* `include_str!` / `include_bytes!` -- –≤—Å—Ç–∞–≤–∏—Ç—å —Ä–µ—Å—É—Ä—Å –≤ –±–∏–Ω–∞—Ä—å: +
  [.language-rust]`const LOGO: &[u8] = include_bytes!("assets/logo.png")`

* `file!` / `line!` / `column!` -- –∏–º—è —Ñ–∞–π–ª–∞, —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–æ–∫–∞, –ø–æ–∑–∏—Ü–∏—è

* `stringify!` -- –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç –≤ —Å—Ç—Ä–æ–∫—É

* `format_args!` -- –≥–ª–∞–≤–Ω—ã–π `prlint`-style –º–∞–∫—Ä–æ—Å, –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç +
    [.language-rust]`"foo = {}", foo` –≤ [.language-rust]`FormatArgs<'a>`


[.title-slide]
== –£—Å–ª–æ–≤–Ω–∞—è –ö–æ–º–ø–∏–ª—è—Ü–∏—è

== !

[source,rust]
----
#[cfg(unix)]
pub fn bytes2path(bytes: &[u8]) -> CargoResult<PathBuf> {
    use std::os::unix::prelude::*;
    Ok(PathBuf::from(OsStr::from_bytes(bytes)))
}

#[cfg(windows)]
pub fn bytes2path(bytes: &[u8]) -> CargoResult<PathBuf> {
    use std::str;
    match str::from_utf8(bytes) {
        Ok(s) => Ok(PathBuf::from(s)),
        Err(..) => Err(failure::format_err!(
            "invalid non-unicode path"
        )),
    }
}
----

–ê—Ç—Ä–∏–±—É—Ç `cfg` —Å–∫—Ä—ã–≤–∞–µ—Ç –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è.
–£—Å–ª–æ–≤–Ω–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è -- —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è, –Ω–∞ —ç—Ç–∞–ø–µ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è –º–∞–∫—Ä–æ—Å–æ–≤ :(

== –£—Å–ª–æ–≤–Ω–∞—è –ö–æ–º–ø–∏–ª—è—Ü–∏—è

.–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –Ω–∞–ø–∏—Å–∞–Ω–∏–µ unit-—Ç–µ—Å—Ç–æ–≤:
[source,rust]
----
#[cfg(test)]
mod tests {
    use some_lib::test_specific_function;
    use super::*;

    #[test]
    fn test_foo() { ... }
}
----

* `#[test]` –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–ø–∞–¥–∞—é—Ç –≤ —Ä–µ–∞–ª—å–Ω—ã–π –±–∏–Ω–∞—Ä—å/–±–∏–±–ª–∏–æ—Ç–µ–∫—É
* `#[cfg(test)]` –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç—ã –∏ –∏–∑–±–∞–≤–∏—Ç—Å—è –æ—Ç unused import


== –£—Å–ª–æ–≤–Ω–∞—è –ö–æ–º–ø–∏–ª—è—Ü–∏—è

[source,rust]
----
pub fn dylib_path_envvar() -> &'static str {
    if cfg!(windows) {
        "PATH"
    } else if cfg!(target_os = "macos") {
        "DYLD_FALLBACK_LIBRARY_PATH"
    } else {
        "LD_LIBRARY_PATH"
    }
}
----

–ú–∞–∫—Ä–æ—Å `cfg!` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö

== –£—Å–ª–æ–≤–Ω–∞—è –ö–æ–º–ø–∏–ª—è—Ü–∏—è

[source,rust]
----
fn main() {
    let compile_time_path = env!("PATH");
    println!(
        "PATH at *compile* time:\n{}",
        compile_time_path,
    );
}
----

–ú–∞–∫—Ä–æ—Å—ã `env!` –∏ `option_env!` –ø–æ–∑–≤–æ–ª—è—é—Ç —Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –≤ compile time

[.title-slide]
== –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –ú–∞–∫—Ä–æ—Å—ã

== !

–ú–∞–∫—Ä–æ—Å–∞–º–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ã—á–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:

[source,rust]
----
pub enum TokenTree {
    Group(Group),
    Ident(Ident),
    Punct(Punct),
    Literal(Literal),
}

impl Group {
    pub fn delimiter(&self) -> Delimiter
    pub fn stream(&self) -> TokenStream
}

type TokenStream = Iterator<Item = TokenTree>; // üëã

----

[source,rust]
----
#[proc_macro]
pub fn squared(arg: TokenStream) -> TokenStream {
    format!("({arg}) * ({arg})", arg = arg).parse().unwrap()
}
----

== –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ –ú–∞–∫—Ä–æ—Å—ã

* –Ω–µ—Ç –≥–∏–≥–∏–µ–Ω—ã
* –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞ —É—Ä–æ–≤–Ω–µ –º–æ–¥—É–ª—è (–ø—Ä–∏–º–µ—Ä —Å–æ `squared` –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç)
* –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ—è—Ç—å –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –∫—Ä–µ–π—Ç–µ —Å
+
[source,toml]
----
[lib]
proc-macro = true
----

== Derive

[source,rust]
----
#[derive(Clone, Copy, PartialEq, Eq)]
struct Vec3([f3; 3]);
----

`derive` —ç—Ç–æ —Ç–æ–∂–µ –º–∞–∫—Ä–æ—Å, `derive(Clone)` —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏

–ú–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å —Å–≤–æ–∏ `derive`!

[source,rust]
----
#[proc_macro_derive(MyTrait)]
pub fn derive_my_trait(input: TokenStream) -> TokenStream {
    ...
}
----

== Derive

–î–ª—è `Derive`, –Ω—É–∂–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–µ—Ä–µ–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ ADT

–ö—Ä–µ–π—Ç `syn` –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–∞—Ä—Å–∏—Ç—å –¥–µ—Ä–µ–≤—å—è —Ç–æ–∫–µ–Ω–æ–≤ –≤ AST Rust

`syn` -- –æ–±—ã—á–Ω—ã–π –∫–æ–¥, –Ω–∏–∫–∞–∫ –Ω–µ —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º

== –ü—Ä–∏–º–µ—Ä

–•–æ—Ç—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö –º–∞–∫—Ä–æ—Å–æ–≤ –ø—Ä–æ—Å—Ç–æ–π, API syn –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ!

[source,rust]
----
#[derive(HeapSize)]
struct Demo<'a, T: ?Sized> {
    a: Box<T>,
    b: u8,
    c: &'a str,
    d: String,
}
----

`HeapSize` -- —Ä–∞–∑–º–µ—Ä –æ–±—ä–µ–∫—Ç–∞, —É—á–∏—Ç—ã–≤–∞—è –¥–∞–Ω–Ω—ã–µ –≤ –∫—É—á–µ

"–ì–ª—É–±–æ–∫–∏–π" `std::size_of`

== !

[source,rust]
----
#[proc_macro_derive(HeapSize)]
pub fn derive_heap_size(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;
    let generics = add_trait_bounds(input.generics);
    let (impl_generics, ty_generics, where_clause) =
        generics.split_for_impl();
    let sum = heap_size_sum(&input.data);
    let expanded = quote! {
        impl #impl_generics heapsize::HeapSize
        for #name #ty_generics
            #where_clause
        {
            fn heap_size_of_children(&self) -> usize {
                #sum
            }
        }
    };
    proc_macro::TokenStream::from(expanded)
}
----

== !

[source,rust]
----
fn heap_size_sum(data: &Data) -> TokenStream {
    match *data {
        Data::Struct(ref data) => {
            match data.fields {
                Fields::Unnamed(ref fields) => {
                    let recurse = fields.unnamed.iter()
                        .enumerate().map(|(i, f)| {
                            let index = Index::from(i);
                            quote! {
                                HeapSize::heap_size_of_children(
                                    &self.#index
                                )
                            }
                        });
                    quote! { 0 #(+ #recurse)* }
                }
                Fields::Named(_) | Fields::Unit => panic!("TODO")
            }
        }
        Data::Enum(_) | Data::Union(_) => panic!("TODO")
    }
}
----

== serde

[.text-center.lead]
https://serde.rs/

serde::
–§—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞ Rust

TIP: –û–¥–∏–Ω –∏–∑ —Å–∞–º—ã–π –∑–∞–º–µ—á–∞—Ç–µ–ª—å–Ω—ã—Ö –∫—Ä–µ–π—Ç–æ–≤!

–¢—Ä–µ–π—Ç—ã + –ú–∞–∫—Ä–æ—Å—ã = –≥–∏–±–∫–∞—è –∏ –±—ã—Å—Ç—Ä–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–Ω–µ —è–∑—ã–∫–∞

== serde

–Ø–¥—Ä–æ –¥–∏–∑–∞–π–Ω–∞ -- —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑—É–µ–º—ã–π visitor

[source,rust]
----
#[derive(Serialize)]
struct Rgb {
    r: u8,
    g: u8,
    b: u8,
}
----

== !

[source,rust]
----
struct Rgb {
    r: u8,
    g: u8,
    b: u8,
}

impl Serialize for Rgb {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
      S: Serializer,
  {
      let mut rgb = serializer.serialize_struct("Rgb", 3)?;
      rgb.serialize_field("r", &self.r)?;
      rgb.serialize_field("g", &self.g)?;
      rgb.serialize_field("b", &self.b)?;
      rgb.end()
  }
}
----

–°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π reflection!

== Serialize

[source,rust]
----
pub trait Serialize {
  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  where
      S: Serializer;
}
----

S -- —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö (JSON, YAML, XML)

S -- –ø–∞—Ä–∞–º–µ—Ç—Ä —Ç–∏–ø–∞, –ø–æ—Å–ª–µ –º–æ–Ω–æ—Ñ–æ—Ä—Ñ–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—É—á–∞–µ–º –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–ø—Ä—è–º—É—é —Å–æ–∑–¥–∞—ë—Ç
JSON

== Serializer

[source,rust]
----
pub trait Serializer: Sized {
    type Ok;
    type Error: Error;

    type SerializeStruct
        : SerializeStruct<Ok = Self::Ok, Error = Self::Error>;

    fn serialize_i8(self, v: i8)
        -> Result<Self::Ok, Self::Error>;

    fn serialize_i16(self, v: i16)
        -> Result<Self::Ok, Self::Error>;

    fn serialize_struct(
        self,
        name: &'static str,
        len: usize,
    ) -> Result<Self::SerializeStruct, Self::Error>;
}
----

== !

image::./fin.jpg[width=100%]
